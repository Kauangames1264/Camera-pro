<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Web Camera App v5.2 ‚Äî Super Pixel (stacking + upscale)</title>
<style>
  /* =========================
     Estilos principais
     ========================= */
  :root{
    --bg:#000;
    --panel:rgba(0,0,0,0.6);
    --accent:#00c853;
    --muted:#9aa0a6;
    --white:#ffffff;
    --danger:#ff5252;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;width:100%;margin:0;padding:0;background:var(--bg);color:var(--white);font-family:Inter,Arial,Helvetica,sans-serif; -webkit-font-smoothing:antialiased;}
  *{box-sizing:border-box}
  a{color:inherit}

  /* Container */
  #app{position:relative;height:100dvh;width:100dvw;overflow:hidden}

  /* Video preview */
  .view{position:relative;height:100%;width:100%;display:flex;align-items:center;justify-content:center;background:#000;touch-action:none}
  video#preview{width:100%;height:100%;object-fit:cover;transform-origin:center center;will-change:transform;transition:transform .12s linear, filter .12s linear}
  video#preview.during-zoom{filter:blur(.6px) saturate(.98)}

  /* Topbar */
  .topbar{position:absolute;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:1600}
  .left-top{display:flex;gap:10px;align-items:center}
  .mode-indicator{padding:6px 10px;border-radius:20px;background:rgba(0,0,0,0.4);font-size:13px;color:var(--muted)}
  .status-pill{padding:6px 10px;border-radius:12px;background:var(--panel);font-size:12px;color:var(--muted)}

  /* Zoom text */
  .zoom-text{position:absolute;top:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:8px 14px;border-radius:20px;font-weight:700;z-index:1700;opacity:0;transition:opacity .18s}
  .zoom-text.show{opacity:1}

  /* Controls and presets */
  .modes{position:absolute;bottom:96px;left:50%;transform:translateX(-50%);display:flex;gap:12px;z-index:1400;background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:14px}
  .mode-btn{background:transparent;border:none;color:#ddd;padding:6px 8px;border-radius:8px;cursor:pointer}
  .mode-btn.active{color:#fff;font-weight:700;text-decoration:underline}

  .presets{position:absolute;bottom:172px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:1400}
  .preset{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.04);cursor:pointer}
  .preset.active{background:rgba(0,200,83,0.12);color:var(--accent)}

  /* Primary buttons */
  .shutter{position:absolute;bottom:48px;left:50%;transform:translateX(-50%);width:66px;height:66px;border-radius:50%;background:#fff;color:#000;border:none;font-size:22px;display:flex;align-items:center;justify-content:center;z-index:1300;box-shadow:0 10px 40px rgba(0,0,0,0.6);cursor:pointer}
  .gallery-btn{position:absolute;right:18px;bottom:48px;width:46px;height:46px;border-radius:50%;background:rgba(255,255,255,0.92);display:flex;align-items:center;justify-content:center;z-index:1300;cursor:pointer}

  /* Mini-view (sempre 1x) */
  #mini-wrap{position:absolute;top:18px;right:18px;width:140px;height:140px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.06);background:#000;display:none;z-index:1500}
  #mini-video{width:100%;height:100%;object-fit:cover;transform:none}
  #mini-rect{position:absolute;border:2px solid #00ff66;box-sizing:border-box;pointer-events:none;display:none}

  /* Settings panel */
  .settings{position:absolute;left:12px;top:56px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;z-index:1500;display:none}
  .settings label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
  .settings select{margin:6px 0;padding:6px;border-radius:6px;border:none;background:#111;color:#fff}

  /* Gallery panel */
  #gallery-panel{position:fixed;right:0;top:0;height:100%;width:0;background:rgba(0,0,0,0.94);overflow:auto;transition:width .24s;z-index:1800}
  #gallery-panel.open{width:340px}
  .gallery-item{padding:12px;border-bottom:1px solid rgba(255,255,255,0.03)}
  .gallery-item img,.gallery-item video{width:100%;border-radius:8px;background:#111}

  /* Indicator overlay */
  #processing-overlay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);padding:18px;border-radius:12px;z-index:2500;display:none;min-width:240px;text-align:center}
  #processing-overlay p{margin:8px 0;color:var(--muted);font-size:14px}
  #processing-overlay .progress{height:8px;background:rgba(255,255,255,0.06);border-radius:6px;overflow:hidden;margin-top:8px}
  #processing-overlay .progress > i{display:block;height:100%;width:0%;background:var(--accent);transition:width .2s linear}

  /* Suspended continue button (reveal long code logs or continuation) */
  #suspend-btn{position:fixed;left:50%;transform:translateX(-50%);bottom:6px;background:var(--panel);color:var(--muted);border-radius:20px;padding:6px 12px;border:1px solid rgba(255,255,255,0.04);cursor:pointer;z-index:3000}
  #suspend-panel{position:fixed;left:12px;right:12px;bottom:54px;background:rgba(0,0,0,0.85);padding:12px;border-radius:8px;color:var(--muted);display:none;z-index:3001;max-height:40vh;overflow:auto;font-size:13px}

  /* small responsive tweaks */
  @media(max-width:420px){
    .presets{bottom:156px}
    .modes{bottom:72px}
    .shutter{width:56px;height:56px}
    #mini-wrap{width:96px;height:96px}
    #gallery-panel.open{width:260px}
  }
</style>
</head>
<body>
  <!-- APP -->
  <div id="app" aria-hidden="true">
    <div class="view" id="view">
      <video id="preview" autoplay playsinline muted></video>

      <div class="topbar">
        <div class="left-top">
          <div class="mode-indicator" id="camera-info">Wide ‚Ä¢ 1√ó</div>
          <div class="status-pill" id="connect-status">Aguardando</div>
        </div>
        <div>
          <button id="settings-toggle" class="mode-btn" title="Ajustes">‚öô</button>
        </div>
      </div>

      <div class="zoom-text" id="zoom-text">1√ó</div>

      <div class="modes" id="modes">
        <button class="mode-btn active" data-mode="MP">FOTO / MP</button>
        <button class="mode-btn" data-mode="P">FOTO / P</button>
      </div>

      <div class="presets" id="presets">
        <button class="preset" data-zoom="1">1√ó</button>
        <button class="preset" data-zoom="2">2√ó</button>
        <button class="preset" data-zoom="5">5√ó</button>
        <button class="preset" data-zoom="10">10√ó</button>
        <button class="preset" data-zoom="20">20√ó</button>
      </div>

      <button id="shutter" class="shutter" aria-label="Tirar foto">‚óè</button>
      <button id="gallery-btn" class="gallery-btn" aria-label="Galeria">üì∑</button>

      <div id="mini-wrap">
        <video id="mini-video" autoplay muted playsinline></video>
        <div id="mini-rect"></div>
      </div>

      <div class="settings" id="settings">
        <label>Modo</label>
        <div id="mp-panel">
          <div style="font-size:12px;color:var(--muted)">FOTO / MP</div>
          <select id="mp-select">
            <option value="4">4MP</option>
            <option value="8">8MP</option>
            <option value="12" selected>12MP</option>
            <option value="24">24MP</option>
            <option value="36">36MP</option>
            <option value="48">48MP</option>
          </select>
        </div>
        <div id="p-panel" style="display:none">
          <div style="font-size:12px;color:var(--muted)">FOTO / P</div>
          <select id="p-select">
            <option value="640x480">480p</option>
            <option value="1280x720">720p</option>
            <option value="1920x1080" selected>1080p</option>
            <option value="2560x1440">2K</option>
            <option value="3840x2160">4K</option>
            <option value="8000x6000">8K</option>
          </select>
        </div>
        <div style="height:8px"></div>
        <button id="apply-res" class="mode-btn" style="background:var(--accent);color:#000;border:none;padding:8px 10px;border-radius:8px">APLICAR</button>
      </div>

      <div id="processing-overlay" aria-hidden="true">
        <strong id="processing-title">Processando</strong>
        <p id="processing-msg">Preparando...</p>
        <div class="progress"><i id="processing-bar" style="width:0%"></i></div>
        <div style="height:6px"></div>
        <button id="processing-cancel" class="mode-btn" style="background:transparent;color:var(--danger)">Cancelar</button>
      </div>

      <div id="suspend-panel"></div>
      <button id="suspend-btn">CONTINUAR</button>

      <div id="gallery-panel" aria-hidden="true">
        <div style="display:flex;justify-content:space-between;align-items:center;padding:12px;color:#fff">
          <strong>Galeria</strong>
          <button id="close-gallery" style="background:none;border:none;color:#fff;font-size:20px">‚úï</button>
        </div>
        <div id="gallery-list"></div>
      </div>
    </div>
  </div>

  <!-- canvas escondido: usado para compor Super Pixel -->
  <canvas id="stitch-canvas" style="display:none"></canvas>

<script>
/*
  Web Camera App v5.2
  - Vers√£o: 5.2
  - Implementa Super Pixel via stacking (m√©dia por pixel) + upscale por canvas.
  - Mant√©m fallback via MediaRecorder se ImageCapture ausente.
  - Exibe indicador de processamento e bot√£o "CONTINUAR".
  - Muitas checagens para reduzir crash por limite de canvas.
  - LocalStorage names v5_2 para evitar conflito.
*/

/* =========================
   Helpers e utilit√°rios
   ========================= */
const $ = id => document.getElementById(id);
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const delay = ms => new Promise(r => setTimeout(r, ms));
const logSuspend = (msg) => {
  const panel = $('suspend-panel');
  const p = document.createElement('div');
  p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  panel.prepend(p);
};

/* =========================
   Elementos do DOM
   ========================= */
const app = $('app');
const view = $('view');
const preview = $('preview');
const miniWrap = $('mini-wrap');
const miniVideo = $('mini-video');
const miniRect = $('mini-rect');
const cameraInfo = $('camera-info');
const connectStatus = $('connect-status');
const zoomText = $('zoom-text');
const modes = $('modes');
const modeBtns = modes.querySelectorAll('.mode-btn');
const presets = $('presets');
const shutter = $('shutter');
const galleryBtn = $('gallery-btn');
const settingsToggle = $('settings-toggle');
const settingsPanel = $('settings');
const mpSelect = $('mp-select');
const pSelect = $('p-select');
const applyRes = $('apply-res');
const mpPanel = $('mp-panel');
const pPanel = $('p-panel');
const galleryPanel = $('gallery-panel');
const closeGallery = $('close-gallery');
const galleryList = $('gallery-list');
const processingOverlay = $('processing-overlay');
const processingTitle = $('processing-title');
const processingMsg = $('processing-msg');
const processingBar = $('processing-bar');
const processingCancel = $('processing-cancel');
const suspendBtn = $('suspend-btn');
const suspendPanel = $('suspend-panel');
const stitchCanvas = $('stitch-canvas');

/* =========================
   Estado interno
   ========================= */
let stream = null;
let chosenDeviceId = null;
let devices = [];
let photos = JSON.parse(localStorage.getItem('cam_photos_v5_2') || '[]'); // storage v5_2
const MAX_PHOTOS = 7;

let desiredMode = localStorage.getItem('cam_mode_v5_2') || 'MP'; // MP or P
let cfg = {
  MP: { mp: localStorage.getItem('cam_mp_v5_2') || '12' },
  P:  { p:  localStorage.getItem('cam_p_v5_2')  || '1920x1080' }
};

let zoom = Number(localStorage.getItem('cam_zoom_v5_2') || 1);
let videoTrackCapabilities = null;
let videoTrackSettings = null;
let imageCapture = null;
let processingAbort = false;

/* =========================
   Map MP -> resolution (aproximado)
   ========================= */
function mpToResolution(mp){
  mp = Number(mp);
  if(mp<=4) return {width:1920,height:1080};
  if(mp<=8) return {width:3264,height:2448};
  if(mp<=12) return {width:4000,height:3000};
  if(mp<=24) return {width:6000,height:4000};
  if(mp<=36) return {width:7360,height:4912};
  return {width:8000,height:6000};
}

/* =========================
   Escolha heur√≠stica da traseira principal
   ========================= */
async function pickRearMain(){
  logSuspend('pickRearMain: iniciando heur√≠stica de sele√ß√£o de c√¢mera');
  try{
    // Tenta obter r√≥tulo para melhorar heur√≠stica
    await navigator.mediaDevices.getUserMedia({video:{ facingMode:{ ideal:'environment' }}, audio:false})
      .then(tmp => tmp.getTracks().forEach(t=>t.stop()))
      .catch(()=>{});
  }catch(e){
    // Ignora
  }
  try{
    const list = await navigator.mediaDevices.enumerateDevices();
    const cams = list.filter(d=>d.kind==='videoinput');
    devices = cams;
    if(!cams.length) return null;
    const score = d=>{
      const L = (d.label||'').toLowerCase(); let s=0;
      if(/main|wide|standard|1x|camera 0/.test(L)) s+=8;
      if(/back|rear|environment/.test(L)) s+=4;
      if(/ultra|ultrawide|0\.5x|macro|tele|zoom/.test(L)) s-=10;
      if(/front|selfie|face|user/.test(L)) s-=20;
      return s;
    };
    const sorted = cams.slice().sort((a,b)=>score(b)-score(a));
    logSuspend(`pickRearMain: escolhida deviceId=${sorted[0].deviceId}`);
    return sorted[0].deviceId || cams[0].deviceId;
  }catch(e){
    logSuspend('pickRearMain: erro enumerateDevices -> '+String(e));
    return null;
  }
}

/* =========================
   Aplicar resolu√ß√µes / constraints
   ========================= */
async function tryApplyResolutions(track, list){
  if(!track?.applyConstraints) return;
  for(const r of list){
    try{
      await track.applyConstraints({
        width:{ ideal:r.width },
        height:{ ideal:r.height },
        advanced:[{ width:r.width, height:r.height }]
      });
      const s = track.getSettings?.() || {};
      if(s.width && s.height && s.width >= r.width*0.9 && s.height >= r.height*0.9) {
        logSuspend(`tryApplyResolutions: sucesso para ${r.width}x${r.height}`);
        return;
      }
    }catch(e){
      logSuspend(`tryApplyResolutions: falhou para ${r.width}x${r.height} -> ${e}`);
    }
  }
}

/* =========================
   Abrir c√¢mera conforme modo
   ========================= */
async function openCamera(deviceId){
  processingAbort = false;
  if(stream) stream.getTracks().forEach(t=>t.stop());
  chosenDeviceId = deviceId;
  connectStatus.textContent = 'Conectando...';
  let constraints = { audio:false, video:{ deviceId:{ exact: deviceId }, facingMode:'environment', aspectRatio:{ ideal:16/9 } } };
  if(desiredMode === 'MP'){
    const r = mpToResolution(cfg.MP.mp);
    constraints.video.width = { ideal: r.width };
    constraints.video.height = { ideal: r.height };
  } else {
    const [w,h] = cfg.P.p.split('x').map(Number);
    constraints.video.width = { ideal: w };
    constraints.video.height = { ideal: h };
  }

  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    miniVideo.srcObject = stream;

    const track = stream.getVideoTracks()[0];
    videoTrackCapabilities = track.getCapabilities?.() || null;
    videoTrackSettings = track.getSettings?.() || null;

    // tenta aplicar resolu√ß√µes de forma decrescente para alcan√ßar o melhor
    if(desiredMode === 'MP'){
      const target = mpToResolution(cfg.MP.mp);
      const steps = [
        {width:8000,height:6000},
        {width:7360,height:4912},
        {width:6000,height:4000},
        {width:4000,height:3000},
        {width:3264,height:2448},
        {width:1920,height:1080}
      ].filter(r => r.width <= target.width && r.height <= target.height);
      await tryApplyResolutions(track, steps);
    } else {
      const [w,h] = cfg.P.p.split('x').map(Number);
      await tryApplyResolutions(track, [{width:w, height:h}]);
    }

    // foco cont√≠nuo quando suportado
    try{
      const caps = track.getCapabilities?.() || {};
      if(caps.focusMode?.includes?.('continuous')){
        await track.applyConstraints({ advanced:[{ focusMode:'continuous' }] });
      }
    }catch(e){
      logSuspend('openCamera: aplicar focusMode falhou -> '+String(e));
    }

    // criar ImageCapture se poss√≠vel
    try{
      imageCapture = new ImageCapture(track);
    }catch(e){
      imageCapture = null;
    }

    // aplicar zoom final salvo
    try { await applyZoomFinalize(zoom); } catch(e){}

    updateCameraInfo();
    connectStatus.textContent = 'Pronto';
    if(zoom > 2) showMini(); else hideMini();
    logSuspend('openCamera: sucesso e stream atribu√≠do');
  } catch(err){
    logSuspend('openCamera: erro ao abrir -> ' + String(err));
    alert('Erro ao abrir c√¢mera: '+(err?.message || err));
    connectStatus.textContent = 'Erro';
  }
}

/* =========================
   Mini-view show/hide
   ========================= */
function showMini(){ miniWrap.style.display = 'block'; }
function hideMini(){ miniWrap.style.display = 'none'; }

/* =========================
   Zoom UI helpers
   ========================= */
function refreshZoomText(){
  zoomText.textContent = `${formatZoom(zoom)}√ó`;
  zoomText.classList.add('show');
  setTimeout(()=>zoomText.classList.remove('show'), 700);
}
function updateCameraInfo(){
  cameraInfo.textContent = `Wide ‚Ä¢ ${formatZoom(zoom)}√ó ‚Ä¢ ${videoTrackSettings?.width||'?'}√ó${videoTrackSettings?.height||'?'}`;
}
function formatZoom(z){ return (z>=10?Math.round(z):Math.max(1,Math.round(z*10)/10)); }

/* =========================
   Mini rect c√°lculo geom√©trico (1x mini view)
   ========================= */
function updateMiniRect(){
  if(zoom <= 1){ miniRect.style.display = 'none'; return; }
  if(!miniVideo.clientWidth || !miniVideo.clientHeight){ miniRect.style.display = 'none'; return; }
  miniRect.style.display = 'block';
  const mw = miniVideo.clientWidth, mh = miniVideo.clientHeight;
  const frac = 1/zoom;
  const w = mw * frac, h = mh * frac;
  const left = (mw - w) / 2, top = (mh - h) / 2;
  miniRect.style.width = `${w}px`;
  miniRect.style.height = `${h}px`;
  miniRect.style.left = `${left}px`;
  miniRect.style.top = `${top}px`;
}

/* =========================
   Zoom live and finalize
   ========================= */
function applyZoomLiveDigital(z){
  z = clamp(z, 1, 100);
  preview.classList.add('during-zoom');
  preview.style.transform = `scale(${z})`;
  zoom = z;
  refreshZoomText();
  updateMiniRect();
  if(zoom>2) showMini(); else hideMini();
  updateCameraInfo();
}

async function applyZoomFinalize(z){
  z = clamp(Math.round(z*10)/10, 1, 100);
  const track = stream?.getVideoTracks?.()[0];
  const hasHW = !!(videoTrackCapabilities && 'zoom' in videoTrackCapabilities && track?.applyConstraints);
  let appliedHW = 1;
  if(hasHW){
    const hwMin = Number(videoTrackCapabilities.zoom.min || 1);
    const hwMax = Number(videoTrackCapabilities.zoom.max || 1);
    const hwTarget = clamp(z, hwMin, hwMax);
    try{
      await track.applyConstraints({ advanced:[{ zoom: hwTarget }] });
      const s = track.getSettings?.() || {};
      appliedHW = Number(s.zoom || hwTarget) || hwTarget;
    }catch(e){
      logSuspend('applyZoomFinalize: aplicar zoom HW falhou -> '+String(e));
      appliedHW = 1;
    }
  }
  const digitalFactor = Math.max(1, z / appliedHW);
  preview.style.transform = digitalFactor>1 ? `scale(${digitalFactor})` : 'scale(1)';
  preview.classList.remove('during-zoom');
  zoom = z;
  localStorage.setItem('cam_zoom_v5_2', String(zoom));
  refreshZoomText();
  updateMiniRect();
  if(zoom>2) showMini(); else hideMini();
  try{ videoTrackSettings = stream?.getVideoTracks?.()[0]?.getSettings?.() || videoTrackSettings; }catch(e){}
  updateCameraInfo();
}

/* =========================
   Gestos pinch / wheel
   ========================= */
let pinchStartDist = null, pinchStartZoom = null;
view.addEventListener('touchstart', e=>{
  if(e.touches.length === 2){
    pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    pinchStartZoom = zoom;
    zoomText.classList.add('show');
  }
},{passive:true});

view.addEventListener('touchmove', e=>{
  if(e.touches.length === 2 && pinchStartDist){
    e.preventDefault();
    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const ratio = d / pinchStartDist;
    const z = clamp(pinchStartZoom * ratio, 1, 100);
    applyZoomLiveDigital(z);
  }
},{passive:false});

view.addEventListener('touchend', async e=>{
  if(e.touches.length < 2 && pinchStartDist){
    pinchStartDist = null; pinchStartZoom = null;
    await applyZoomFinalize(zoom);
  }
},{passive:true});

view.addEventListener('wheel', e=>{
  if(Math.abs(e.deltaY) < 1) return;
  e.preventDefault();
  const dir = e.deltaY < 0 ? 1 : -1;
  const z = clamp(zoom + dir*0.2, 1, 100);
  applyZoomLiveDigital(z);
  clearTimeout(view.__wheelT);
  view.__wheelT = setTimeout(()=>applyZoomFinalize(zoom), 140);
},{passive:false});

/* =========================
   Presets wiring
   ========================= */
presets.querySelectorAll('.preset').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    presets.querySelectorAll('.preset').forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    const z = clamp(Number(btn.dataset.zoom) || 1, 1, 100);
    applyZoomLiveDigital(z);
    await applyZoomFinalize(z);
  });
});

/* =========================
   Blob -> DataURL
   ========================= */
function blobToDataURL(blob){
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onload = ()=>res(fr.result);
    fr.onerror = rej;
    fr.readAsDataURL(blob);
  });
}

/* =========================
   Galeria local
   ========================= */
function pushPhoto(item){
  item.ts = Date.now();
  if(photos.length >= MAX_PHOTOS) photos.shift();
  photos.push(item);
  localStorage.setItem('cam_photos_v5_2', JSON.stringify(photos));
  refreshGalleryList();
  logSuspend(`pushPhoto: guardado item tipo=${item.type} super=${!!item.super} parts=${item.parts||0}`);
}
function refreshGalleryList(){
  galleryList.innerHTML = '';
  photos.slice().reverse().forEach((p,i)=>{
    const wrap = document.createElement('div'); wrap.className = 'gallery-item';
    if(p.type === 'image'){
      const img = document.createElement('img'); img.src = p.dataUrl; wrap.appendChild(img);
      const a = document.createElement('a'); a.href = p.dataUrl; a.download = `photo_${photos.length-i}.jpg`; a.textContent = 'Download'; a.style.color = '#0f0'; a.style.display = 'block'; a.style.marginTop = '6px';
      wrap.appendChild(a);
      if(p.super){
        const info = document.createElement('div'); info.style.fontSize='12px'; info.style.color='var(--muted)'; info.textContent = `Super Pixel: ${p.parts}x (${p.composedWidth}√ó${p.composedHeight})`; wrap.appendChild(info);
      }
    } else if(p.type === 'video'){
      const vid = document.createElement('video'); vid.src = p.dataUrl; vid.controls = true; wrap.appendChild(vid);
      const a = document.createElement('a'); a.href = p.dataUrl; a.download = `clip_${photos.length-i}.webm`; a.textContent = 'Download'; a.style.color = '#0f0'; a.style.display = 'block'; a.style.marginTop = '6px';
      wrap.appendChild(a);
    } else if(p.type === 'package'){
      const info = document.createElement('div'); info.style.fontSize='13px'; info.style.color='var(--muted)'; info.textContent = `Pacote Super (${p.parts} imagens)`; wrap.appendChild(info);
      (p.items || []).forEach((d, idx)=>{
        const img = document.createElement('img'); img.src = d; img.style.marginTop='8px'; wrap.appendChild(img);
      });
    }
    galleryList.appendChild(wrap);
  });
}

/* =========================
   Seguran√ßa: stop stream quando aba oculta
   ========================= */
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    if(stream) stream.getTracks().forEach(t=>t.stop());
    connectStatus.textContent = 'Pausado';
    logSuspend('visibilitychange: aba oculta, stream parado para economizar recursos.');
  } else {
    // reabrir camera se estava aberto antes (tentativa)
    if(chosenDeviceId) openCamera(chosenDeviceId).catch(()=>{});
  }
});

/* =========================
   Process overlay helpers
   ========================= */
function showProcessing(title='Processando', msg='Aguarde...', progress=0){
  processingTitle.textContent = title;
  processingMsg.textContent = msg;
  processingBar.style.width = `${progress}%`;
  processingOverlay.style.display = 'block';
  processingOverlay.setAttribute('aria-hidden','false');
  logSuspend(`showProcessing: ${title} - ${msg}`);
}
function updateProcessing(msg, progress){
  if(processingOverlay.style.display === 'none') showProcessing('Processando', msg, progress||0);
  processingMsg.textContent = msg;
  processingBar.style.width = `${progress||0}%`;
  logSuspend(`updateProcessing: ${msg} (${progress}%)`);
}
function hideProcessing(){
  processingOverlay.style.display = 'none';
  processingOverlay.setAttribute('aria-hidden','true');
  processingBar.style.width = '0%';
  logSuspend('hideProcessing');
}

/* =========================
   Detecta se a c√¢mera suporta o MP pedido
   ========================= */
function cameraSupportsMP(targetMP){
  const target = mpToResolution(targetMP);
  const curW = videoTrackSettings?.width || 0;
  const curH = videoTrackSettings?.height || 0;
  if(curW && curH){
    if(curW >= target.width*0.9 && curH >= target.height*0.9) return true;
  }
  const capWmax = videoTrackCapabilities?.width?.max || 0;
  const capHmax = videoTrackCapabilities?.height?.max || 0;
  if(capWmax && capHmax){
    if(capWmax >= target.width*0.9 && capHmax >= target.height*0.9) return true;
  }
  return false;
}

/* =========================
   Captura m√∫ltiplas fotos (ImageCapture) -> retorna array de Blobs
   ========================= */
async function captureMultiplePhotos(count, opts){
  if(!stream) throw new Error('Stream indispon√≠vel');
  const track = stream.getVideoTracks?.()[0];
  if(!track) throw new Error('Track n√£o dispon√≠vel');
  if(!window.ImageCapture || !imageCapture) throw new Error('ImageCapture n√£o suportado');
  const blobs = [];
  for(let i=0;i<count;i++){
    if(processingAbort) throw new Error('cancelado');
    try{
      // ajuste de exposi√ß√£o entre capturas pode ser necess√°rio, adicionar pequenos delays
      await delay(80);
      const b = await imageCapture.takePhoto(opts).catch(err=>{ throw err; });
      blobs.push(b);
      updateProcessing(`Capturando parte ${i+1}/${count}`, Math.round((i+1)/count*30));
    }catch(e){
      logSuspend('captureMultiplePhotos: falha em takePhoto -> '+String(e));
      throw e;
    }
  }
  return blobs;
}

/* =========================
   Converte Blobs em ImageBitmap
   ========================= */
async function blobsToBitmaps(blobs){
  const bitmaps = [];
  for(let i=0;i<blobs.length;i++){
    if(processingAbort) throw new Error('cancelado');
    try{
      const ib = await createImageBitmap(blobs[i]);
      bitmaps.push(ib);
      updateProcessing(`Convertendo ${i+1}/${blobs.length}`, 30 + Math.round((i+1)/blobs.length*15));
    }catch(e){
      logSuspend('blobsToBitmaps: createImageBitmap falhou -> '+String(e));
      throw e;
    }
  }
  return bitmaps;
}

/* =========================
   M√©dia pixel a pixel (stacking)
   bitmaps -> ImageData array -> merged ImageData
   ========================= */
function averageImageData(imageDatas){
  if(!imageDatas.length) throw new Error('Nenhum ImageData para mesclar');
  const w = imageDatas[0].width;
  const h = imageDatas[0].height;
  const merged = new ImageData(w, h);
  const length = merged.data.length;
  const parts = imageDatas.length;

  // iterar por pixel. Trabalha em blocos para performance.
  for(let i=0;i<length;i+=4){
    let r=0,g=0,b=0,a=0;
    for(let p=0;p<parts;p++){
      const d = imageDatas[p].data;
      r += d[i]; g += d[i+1]; b += d[i+2]; a += d[i+3];
    }
    merged.data[i]   = Math.round(r / parts);
    merged.data[i+1] = Math.round(g / parts);
    merged.data[i+2] = Math.round(b / parts);
    merged.data[i+3] = Math.round(a / parts);
  }
  return merged;
}

/* =========================
   Stitch / upscale: desenha mergedImageData (w,h) em canvas final (targetW,targetH)
   Retorna Blob (jpeg)
   ========================= */
async function stitchAndUpscale(mergedImageData, targetW, targetH, mime='image/jpeg', quality=0.94){
  // Prote√ß√£o contra canvas gigantes
  const MAX_CANVAS_PIXELS = 12000 * 12000; // te√≥rico, muitos navegadores falham antes disso
  if(targetW * targetH > MAX_CANVAS_PIXELS) throw new Error('Tamanho da composi√ß√£o excede limite seguro do canvas');

  try{
    stitchCanvas.width = mergedImageData.width;
    stitchCanvas.height = mergedImageData.height;
    const ctx = stitchCanvas.getContext('2d');
    ctx.putImageData(mergedImageData, 0, 0);

    // upscale: desenha em canvas final (novo)
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = targetW;
    finalCanvas.height = targetH;
    const fctx = finalCanvas.getContext('2d');

    // op√ß√£o de preservar nitidez: desenhar com imageSmoothingQuality
    fctx.imageSmoothingEnabled = true;
    fctx.imageSmoothingQuality = 'high';

    // draw scaled
    fctx.drawImage(stitchCanvas, 0, 0, mergedImageData.width, mergedImageData.height, 0, 0, targetW, targetH);

    updateProcessing('Gerando imagem final', 90);

    const blob = await new Promise((res, rej) => {
      finalCanvas.toBlob(b => {
        if(b) res(b); else rej(new Error('toBlob retornou nulo'));
      }, mime, quality);
    });

    updateProcessing('Conclu√≠do', 100);
    return blob;
  }catch(e){
    logSuspend('stitchAndUpscale: erro -> '+String(e));
    throw e;
  }
}

/* =========================
   Captura Super Pixel (stacking + upscale)
   parts: 3 (36MP) ou 4 (48MP)
   ========================= */
async function captureSuperPixel(parts){
  processingAbort = false;
  try{
    showProcessing('Processando Super Pixel','Iniciando captura e composi√ß√£o', 5);
    logSuspend(`captureSuperPixel: iniciar parts=${parts}`);

    // define dimens√µes base (12MP) e target final
    const baseMP = 12;
    const baseRes = mpToResolution(baseMP);
    const targetMP = baseMP * parts;
    const targetRes = mpToResolution(targetMP);

    // check abort
    processingCancel.onclick = ()=>{ processingAbort = true; logSuspend('Usu√°rio cancelou process'); };

    // 1) Captura N fotos em 12MP
    let blobs;
    try{
      const opts = { imageWidth: baseRes.width, imageHeight: baseRes.height };
      updateProcessing('Capturando imagens (fase 1)', 10);
      blobs = await captureMultiplePhotos(parts, opts);
    }catch(e){
      hideProcessing();
      throw new Error('Falha ao capturar fotos: ' + (e?.message || e));
    }

    if(processingAbort){ hideProcessing(); throw new Error('cancelado'); }

    // 2) Converter blobs -> bitmaps
    updateProcessing('Convertendo imagens', 30);
    const bitmaps = await blobsToBitmaps(blobs);

    if(processingAbort){ hideProcessing(); throw new Error('cancelado'); }

    // 3) obter ImageData de cada bitmap
    updateProcessing('Extraindo pixels', 45);
    const imageDatas = [];
    for(let i=0;i<bitmaps.length;i++){
      if(processingAbort) throw new Error('cancelado');
      const bm = bitmaps[i];
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = bm.width;
      tmpCanvas.height = bm.height;
      const tctx = tmpCanvas.getContext('2d');
      tctx.drawImage(bm, 0, 0);
      const id = tctx.getImageData(0,0,tmpCanvas.width,tmpCanvas.height);
      imageDatas.push(id);
      updateProcessing(`Extraindo pixels ${i+1}/${bitmaps.length}`, 45 + Math.round((i+1)/bitmaps.length*10));
      // liberar bitmap
      try{ bm.close?.(); }catch(e){}
    }

    if(processingAbort){ hideProcessing(); throw new Error('cancelado'); }

    // 4) m√©dia pixel a pixel
    updateProcessing('Mesclando imagens (stacking)', 60);
    const merged = averageImageData(imageDatas);

    if(processingAbort){ hideProcessing(); throw new Error('cancelado'); }

    // 5) stitch + upscale para target resolution
    updateProcessing('Compondo e ampliando imagem', 70);
    let composedBlob;
    try{
      composedBlob = await stitchAndUpscale(merged, targetRes.width, targetRes.height, 'image/jpeg', 0.94);
    }catch(e){
      // tentativa alternativa: se tamanho muito grande, reduzir upscale para metade e avisar
      logSuspend('captureSuperPixel: stitch falhou -> ' + String(e));
      // fallback: tentar upscale moderado (meia resolu√ß√£o)
      try{
        updateProcessing('Fallback: tentanto composi√ß√£o em resolu√ß√£o intermedi√°ria', 75);
        const fallbackW = Math.min(8000, Math.floor(targetRes.width/2));
        const fallbackH = Math.min(6000, Math.floor(targetRes.height/2));
        composedBlob = await stitchAndUpscale(merged, fallbackW, fallbackH, 'image/jpeg', 0.92);
        logSuspend('captureSuperPixel: fallback succeed at ' + fallbackW + 'x' + fallbackH);
      }catch(err2){
        // se tudo falhar, salvar pacote das imagens separadas
        hideProcessing();
        logSuspend('captureSuperPixel: fallback tamb√©m falhou. Salvando pacote de imagens individuais.');
        const dataUrls = [];
        for(const b of blobs){ dataUrls.push(await blobToDataURL(b)); }
        pushPhoto({ type:'package', items:dataUrls, parts });
        return;
      }
    }

    if(processingAbort){ hideProcessing(); throw new Error('cancelado'); }

    // 6) push final composto na galeria
    const dataUrl = await blobToDataURL(composedBlob);
    const composedWidth = targetRes.width;
    const composedHeight = targetRes.height;
    pushPhoto({ type:'image', dataUrl, super:true, parts, composedWidth, composedHeight });
    hideProcessing();
    logSuspend('captureSuperPixel: conclu√≠do com sucesso');
  }catch(err){
    hideProcessing();
    if(String(err).toLowerCase().includes('cancelado')) {
      alert('Captura cancelada pelo usu√°rio.');
      logSuspend('captureSuperPixel: cancelado pelo usu√°rio.');
    } else {
      alert('Erro no Super Pixel: ' + (err?.message || err));
      logSuspend('captureSuperPixel: erro final -> '+String(err));
    }
  } finally {
    processingAbort = false;
  }
}

/* =========================
   Fun√ß√£o principal de captura (integra Super Pixel)
   ========================= */
async function captureImage(){
  shutter.disabled = true;
  try{
    // flash UI
    flashEffect();

    const track = stream?.getVideoTracks?.()[0];
    if(!track){ alert('C√¢mera indispon√≠vel'); shutter.disabled = false; return; }

    // Se modo MP e selecionado 36/48 e c√¢mera n√£o suportar, chamar SuperPixel
    if(desiredMode === 'MP'){
      const requestedMP = Number(cfg.MP.mp);
      if((requestedMP === 36 || requestedMP === 48) && !cameraSupportsMP(requestedMP)){
        const parts = requestedMP / 12; // 36=>3, 48=>4
        await captureSuperPixel(parts);
        shutter.disabled = false;
        return;
      }
    }

    // Caso normal: preferir ImageCapture.takePhoto
    if(window.ImageCapture && imageCapture){
      try{
        const opts = {};
        if(desiredMode === 'MP'){
          const r = mpToResolution(cfg.MP.mp);
          opts.imageWidth = r.width; opts.imageHeight = r.height;
        } else {
          const [w,h] = cfg.P.p.split('x').map(Number);
          opts.imageWidth = w; opts.imageHeight = h;
        }
        const blob = await imageCapture.takePhoto(opts).catch(()=>imageCapture.takePhoto());
        if(blob){
          const dataUrl = await blobToDataURL(blob);
          pushPhoto({ type:'image', dataUrl });
          shutter.disabled = false;
          return;
        }
      }catch(e){
        logSuspend('captureImage: ImageCapture.takePhoto falhou -> '+String(e));
        // cair para fallback
      }
    }

    // fallback: grava curto clipe WebM e salva como "video"
    const recBlob = await recordShortClip(stream, 300);
    if(recBlob){
      const dataUrl = await blobToDataURL(recBlob);
      pushPhoto({ type:'video', dataUrl });
    } else {
      alert('Falha ao capturar. Tente novamente.');
    }
  }catch(err){
    alert('Erro ao capturar: ' + (err?.message || err));
    logSuspend('captureImage: erro -> '+String(err));
  } finally {
    shutter.disabled = false;
  }
}

/* =========================
   MediaRecorder curto
   ========================= */
function recordShortClip(ms=200){
  return new Promise((resolve)=>{
    if(!stream || !window.MediaRecorder){ resolve(null); return; }
    let chunks = [];
    let mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
    let rec;
    try{
      rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 1_500_000 });
    }catch(e){ resolve(null); return; }
    rec.ondataavailable = e => { if(e.data?.size) chunks.push(e.data); };
    rec.onstop = () => { resolve(new Blob(chunks, { type: mime })); };
    rec.start();
    setTimeout(()=>{ try{ rec.stop(); } catch(e){ resolve(null); } }, ms);
  });
}

/* =========================
   Flash overlay (visual)
   ========================= */
function flashEffect(){
  const el = document.createElement('div');
  el.style.position = 'fixed'; el.style.inset = '0'; el.style.background = 'white';
  el.style.opacity = '0'; el.style.zIndex = 99999; el.style.transition = 'opacity .12s';
  document.body.appendChild(el);
  requestAnimationFrame(()=> el.style.opacity = '0.85');
  setTimeout(()=>{ el.style.opacity = '0'; setTimeout(()=>el.remove(),160); }, 140);
}

/* =========================
   UI wiring: bot√µes e eventos
   ========================= */
$('suspend-btn').addEventListener('click', ()=>{
  const panel = suspendPanel;
  if(panel.style.display === 'block'){ panel.style.display = 'none'; suspendBtn.textContent = 'CONTINUAR'; }
  else{ panel.style.display = 'block'; suspendBtn.textContent = 'OCULTAR'; }
});

$('processing-cancel').addEventListener('click', ()=>{ processingAbort = true; logSuspend('Usu√°rio solicitou cancelamento do processamento'); });

$('settings-toggle').addEventListener('click', ()=>{ settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block'; });

applyRes.addEventListener('click', async ()=>{
  cfg.MP.mp = mpSelect.value;
  cfg.P.p = pSelect.value;
  localStorage.setItem('cam_mp_v5_2', cfg.MP.mp);
  localStorage.setItem('cam_p_v5_2', cfg.P.p);
  showTemp('Aplicando resolu√ß√£o...', 900);
  if(chosenDeviceId) await openCamera(chosenDeviceId);
});

modeBtns.forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    modeBtns.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    desiredMode = btn.dataset.mode;
    localStorage.setItem('cam_mode_v5_2', desiredMode);
    mpPanel.style.display = desiredMode === 'MP' ? 'block' : 'none';
    pPanel.style.display = desiredMode === 'P' ? 'block' : 'none';
    if(chosenDeviceId) await openCamera(chosenDeviceId);
  });
});

/* shutter, gallery, close gallery */
shutter.addEventListener('click', captureImage);
galleryBtn.addEventListener('click', ()=>{ galleryPanel.classList.toggle('open'); refreshGalleryList(); });
closeGallery.addEventListener('click', ()=> galleryPanel.classList.remove('open'));

/* Presets click: handled earlier via delegated NodeList setup */
/* Init UI */
(function initUI(){
  modeBtns.forEach(b=>b.classList.toggle('active', b.dataset.mode === desiredMode));
  mpPanel.style.display = desiredMode === 'MP' ? 'block' : 'none';
  pPanel.style.display  = desiredMode === 'P'  ? 'block' : 'none';
  mpSelect.value = cfg.MP.mp;
  pSelect.value = cfg.P.p;
  refreshGalleryList();
  refreshZoomText();
})();

/* Resize listener -> update mini rect */
window.addEventListener('resize', ()=>{ if(zoom>1) updateMiniRect(); });

/* getUserMedia support check */
if(!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)){
  alert('Seu navegador n√£o suporta getUserMedia. Use Chrome/Edge/Firefox/Safari atualizados.');
}

/* Debug: estado global */
window.__cam_state_v5_2 = ()=>({
  chosenDeviceId, devices, zoom, videoTrackSettings, videoTrackCapabilities, photos, desiredMode, cfg, imageCapture
});

/* =========================
   Inicializa√ß√£o: pegar c√¢mera automaticamente ao aceitar
   ========================= */
(async function initCameraFlow(){
  app.style.display = 'block';
  logSuspend('initCameraFlow: iniciando fluxo de inicializa√ß√£o v5.2');

  try{
    const devId = await pickRearMain();
    if(!devId){
      alert('Nenhuma c√¢mera traseira encontrada');
      connectStatus.textContent = 'Nenhuma c√¢mera';
      return;
    }
    await openCamera(devId);
  }catch(e){
    logSuspend('initCameraFlow: erro -> '+String(e));
  }
})();

/* =========================
   Fun√ß√µes utilit√°rias adicionais
   ========================= */
function showTemp(txt, ms=1200){
  const prev = cameraInfo.textContent;
  cameraInfo.textContent = txt;
  cameraInfo.classList.add('show');
  setTimeout(()=>{ cameraInfo.textContent = prev; cameraInfo.classList.remove('show'); }, ms);
}

/* =========================
   LOG inicial para painel suspenso
   ========================= */
logSuspend('App v5.2 iniciado');
logSuspend('Instru√ß√µes: use o bot√£o de captura. Se selecionar 36MP/48MP e sua c√¢mera n√£o suportar, o app far√° Super Pixel com 3/4 fotos e compor√°.');

</script>
</body>
</html>
