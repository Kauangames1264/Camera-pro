<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Web Camera App v3.8</title>
<style>
:root{--bg:#000;--accent:#00c853;--muted:#9aa0a6;--panel:rgba(0,0,0,0.55);--white:#fff}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;width:100%;background:var(--bg);font-family:Inter,Arial,Helvetica,sans-serif;color:var(--white);-webkit-user-select:none;user-select:none}
#consent-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.88);display:flex;align-items:center;justify-content:center;z-index:2000}
#consent-overlay .box{background:#111;padding:18px;border-radius:10px;max-width:92%;text-align:center}
.btn{padding:10px 14px;border-radius:8px;border:none;cursor:pointer}
.btn-accept{background:var(--accent);color:#000;font-weight:700}
.btn-decline{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff}

#app{display:none;position:relative;height:100dvh;width:100dvw;overflow:hidden}
.view{position:relative;height:100%;width:100%;display:flex;align-items:center;justify-content:center;background:#000;touch-action:none}
video#preview{width:100%;height:100%;object-fit:cover;transform-origin:center center;will-change:transform;transition:transform .18s ease}
.topbar{position:absolute;top:10px;left:12px;right:12px;display:flex;justify-content:space-between;align-items:center;z-index:1200}
.mode-indicator{padding:6px 10px;border-radius:20px;background:rgba(0,0,0,0.4);font-size:13px;color:var(--muted)}
.zoom-text{position:absolute;top:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);padding:8px 14px;border-radius:20px;font-weight:700;z-index:1300;opacity:0;transition:opacity .25s}
.zoom-text.show{opacity:1}
.modes{position:absolute;bottom:84px;left:50%;transform:translateX(-50%);display:flex;gap:12px;z-index:1200;background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:14px}
.mode-btn{background:transparent;border:none;color:#ddd;padding:6px 8px;border-radius:8px;cursor:pointer}
.mode-btn.active{color:#fff;font-weight:700;text-decoration:underline}
.controls{position:absolute;bottom:140px;width:100%;display:flex;justify-content:center;z-index:1100}
.presets{display:flex;gap:8px;align-items:center}
.preset{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.04);cursor:pointer}
.preset.active{background:rgba(0,200,83,0.12);color:var(--accent)}
.shutter{position:absolute;bottom:48px;left:50%;transform:translateX(-50%);width:64px;height:64px;border-radius:50%;background:#fff;color:#000;border:none;font-size:22px;display:flex;align-items:center;justify-content:center;z-index:1000;box-shadow:0 8px 30px rgba(0,0,0,0.6);cursor:pointer}
.gallery-btn{position:absolute;right:18px;bottom:48px;width:46px;height:46px;border-radius:50%;background:rgba(255,255,255,0.92);display:flex;align-items:center;justify-content:center;z-index:1000;cursor:pointer}

#mini-wrap{position:absolute;top:18px;right:18px;width:128px;height:128px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.06);background:#000;display:none;z-index:1200}
#mini-video{width:100%;height:100%;object-fit:cover}
#mini-rect{position:absolute;border:2px solid #00ff66;box-sizing:border-box;pointer-events:none}

.settings{position:absolute;left:12px;top:56px;background:rgba(0,0,0,0.6);padding:8px;border-radius:8px;z-index:1200;display:none}
.settings select{margin:6px 0;padding:6px;border-radius:6px;border:none;background:#111;color:#fff}

#gallery-panel{position:fixed;right:0;top:0;height:100%;width:0;background:rgba(0,0,0,0.94);overflow:auto;transition:width .24s;z-index:1500}
#gallery-panel.open{width:280px}
.gallery-item{padding:12px;border-bottom:1px solid rgba(255,255,255,0.03)}
.gallery-item img{width:100%;border-radius:8px}

canvas#capture-canvas{display:none}

@media(max-width:420px){.presets{gap:6px}.preset{padding:5px 6px}.shutter{width:56px;height:56px}}
</style>
</head>
<body>
  <div id="consent-overlay">
    <div class="box">
      <p>Este app usa a c√¢mera traseira principal (wide). Fotos salvas localmente (at√© 7).</p>
      <div style="margin-top:12px;display:flex;justify-content:center;gap:10px">
        <button id="agree-btn" class="btn btn-accept">ABRIR C√ÇMERA</button>
        <button id="decline-btn" class="btn btn-decline">CANCELAR</button>
      </div>
    </div>
  </div>

  <div id="app" aria-hidden="true">
    <div class="view" id="view">
      <video id="preview" autoplay playsinline muted></video>

      <div class="topbar">
        <div class="mode-indicator" id="camera-info">Wide ‚Ä¢ 1√ó</div>
        <div style="display:flex;gap:8px;align-items:center">
          <div id="settings-toggle" class="mode-btn" title="Ajustes">‚öô</div>
        </div>
      </div>

      <div class="zoom-text" id="zoom-text">1√ó</div>

      <div class="modes" id="modes">
        <button class="mode-btn active" data-mode="MP">FOTO / MP</button>
        <button class="mode-btn" data-mode="P">FOTO / P</button>
      </div>

      <div class="controls"><div class="presets" id="presets">
        <button class="preset" data-zoom="1">1√ó</button>
        <button class="preset" data-zoom="2">2√ó</button>
        <button class="preset" data-zoom="5">5√ó</button>
        <button class="preset" data-zoom="10">10√ó</button>
        <button class="preset" data-zoom="20">20√ó</button>
      </div></div>

      <button id="shutter" class="shutter" aria-label="Tirar foto">‚óè</button>
      <button id="gallery-btn" class="gallery-btn" aria-label="Galeria">üì∑</button>

      <div id="mini-wrap"><video id="mini-video" autoplay muted playsinline></video><div id="mini-rect"></div></div>

      <div class="settings" id="settings">
        <div style="margin-bottom:6px"><strong style="font-size:13px">Modo</strong></div>
        <div id="mp-panel">
          <div style="font-size:12px;color:var(--muted)">FOTO / MP</div>
          <select id="mp-select">
            <option value="4">4MP</option><option value="8">8MP</option><option value="12" selected>12MP</option>
            <option value="24">24MP</option><option value="36">36MP</option><option value="48">48MP</option>
          </select>
          <div style="height:8px"></div>
        </div>
        <div id="p-panel" style="display:none">
          <div style="font-size:12px;color:var(--muted)">FOTO / P</div>
          <select id="p-select">
            <option value="640x480">480p</option><option value="1280x720">720p</option>
            <option value="1920x1080" selected>1080p</option><option value="2560x1440">2K</option>
            <option value="3840x2160">4K</option><option value="8000x6000">8K</option>
          </select>
        </div>
        <div style="height:8px"></div>
        <button id="apply-res" class="btn btn-accept" style="width:100%">APLICAR</button>
      </div>

    </div>

    <div id="gallery-panel"><div style="display:flex;justify-content:space-between;align-items:center;padding:12px;color:#fff"><strong>Galeria</strong><button id="close-gallery" style="background:none;border:none;color:#fff;font-size:20px">‚úï</button></div><div id="gallery-list"></div></div>
  </div>

  <canvas id="capture-canvas"></canvas>

<script>
/*
 v3.8 - C√≥digo completo
 Principais pontos:
 - Escolha heur√≠stica da c√¢mera traseira principal (wide) ap√≥s pedir permiss√£o.
 - MP/P separados. Tenta aplicar resolu√ß√£o m√°xima at√© 8000x6000.
 - Zoom h√≠brido at√© 100x. Transi√ß√£o suave via RAF. Valores inteiros.
 - Pinch ajusta zoom e persiste em inteiro.
 - Mini-view ativo somente >2x. Ret√¢ngulo acompanha enquadramento corretamente.
 - Captura: tenta ImageCapture.takePhoto, fallback para canvas drawImage.
 - Galeria local (max 7), persistida em localStorage.
*/

// Helpers
const $ = id => document.getElementById(id);
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const delay = ms => new Promise(r=>setTimeout(r,ms));

/* Elements */
const consent = $('consent-overlay'), agreeBtn = $('agree-btn'), declineBtn = $('decline-btn');
const app = $('app'), view = $('view'), preview = $('preview'), miniWrap = $('mini-wrap'), miniVideo = $('mini-video'), miniRect = $('mini-rect');
const cameraInfo = $('camera-info'), zoomText = $('zoom-text');
const modes = $('modes'), modeBtns = modes.querySelectorAll('.mode-btn');
const presets = $('presets'), shutter = $('shutter'), galleryBtn = $('gallery-btn');
const settingsToggle = $('settings-toggle'), settingsPanel = $('settings'), mpSelect = $('mp-select'), pSelect = $('p-select'), applyRes = $('apply-res');
const mpPanel = $('mp-panel'), pPanel = $('p-panel');
const galleryPanel = $('gallery-panel'), closeGallery = $('close-gallery'), galleryList = $('gallery-list');
const canvas = $('capture-canvas');

let stream = null;
let chosenDeviceId = null;
let devices = [];
let zoom = Number(localStorage.getItem('cam_zoom_v3')||1); // current integer zoom
let targetZoom = zoom;
let animating = false;
let videoTrackCapabilities = null;
let videoTrackSettings = null;
let photos = JSON.parse(localStorage.getItem('cam_photos_v3')||'[]');
const MAX_PHOTOS = 7;
let desiredMode = localStorage.getItem('cam_mode_v3') || 'MP'; // MP or P
let cfg = {
  MP: { mp: localStorage.getItem('cam_mp_v3') || '12' },
  P:  { p: localStorage.getItem('cam_p_v3')  || '1920x1080' }
};

/* ---------- utility: pick rear principal wide ---------- */
async function pickRearMain() {
  // ensure labels available: request temporary permission with environment
  try {
    const tmp = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'environment' } }, audio:false });
    tmp.getTracks().forEach(t=>t.stop());
  } catch(e){ /* ignore: permission flow below will handle */ }

  const list = await navigator.mediaDevices.enumerateDevices();
  const cams = list.filter(d=>d.kind==='videoinput');
  devices = cams;
  if(!cams.length) return null;

  function score(d){
    const L = (d.label||'').toLowerCase();
    let s = 0;
    if(/main|wide|standard|1x|camera 0/.test(L)) s+=8;
    if(/back|rear|environment/.test(L)) s+=4;
    if(/video|camera/.test(L)) s+=1;
    if(/ultra|ultrawide|0\.5x|macro|tele|zoom/.test(L)) s-=10;
    if(/front|selfie|face|user/.test(L)) s-=20;
    return s;
  }
  const sorted = cams.slice().sort((a,b)=>score(b)-score(a));
  return sorted[0].deviceId || cams[0].deviceId;
}

/* ---------- MP to resolution mapping ---------- */
function mpToResolution(mp){
  mp = Number(mp);
  if(mp<=4) return {width:1920,height:1080};
  if(mp<=8) return {width:3264,height:2448};
  if(mp<=12) return {width:4000,height:3000};
  if(mp<=24) return {width:6000,height:4000};
  if(mp<=36) return {width:7360,height:4912};
  return {width:8000,height:6000};
}

/* ---------- try apply resolution steps ---------- */
async function tryApplyResolutions(track, list){
  if(!track || !track.applyConstraints) return;
  for(const r of list){
    try{
      await track.applyConstraints({ width:{ ideal:r.width }, height:{ ideal:r.height }, advanced:[{ width:r.width, height:r.height }] });
      const s = track.getSettings ? track.getSettings() : {};
      if(s.width && s.height){
        // ok if within ~90% to requested
        if(s.width >= r.width*0.9 && s.height >= r.height*0.9) return;
      }
    } catch(e){ /* try next */ }
  }
}

/* ---------- open camera with desired mode/resolution ---------- */
async function openCamera(deviceId){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  chosenDeviceId = deviceId;
  // constraints base
  let constraints = { audio:false, video:{ deviceId:{ exact: deviceId }, facingMode:'environment', aspectRatio:{ ideal:16/9 } } };

  if(desiredMode === 'MP'){
    const r = mpToResolution(cfg.MP.mp);
    constraints.video.width = { ideal: r.width };
    constraints.video.height = { ideal: r.height };
  } else {
    const [w,h] = cfg.P.p.split('x').map(Number);
    constraints.video.width = { ideal: w };
    constraints.video.height = { ideal: h };
  }

  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    preview.srcObject = stream;
    await preview.play().catch(()=>{});
    const track = stream.getVideoTracks()[0];
    videoTrackCapabilities = track.getCapabilities ? track.getCapabilities() : null;
    videoTrackSettings = track.getSettings ? track.getSettings() : null;

    // try maximize closer to target (MP)
    if(desiredMode === 'MP'){
      const target = mpToResolution(cfg.MP.mp);
      const steps = [
        {width:8000,height:6000},
        {width:7360,height:4912},
        {width:6000,height:4000},
        {width:4000,height:3000},
        {width:3264,height:2448},
        {width:1920,height:1080}
      ].filter(r=>r.width<=target.width && r.height<=target.height);
      await tryApplyResolutions(track, steps);
    } else {
      const [w,h] = cfg.P.p.split('x').map(Number);
      await tryApplyResolutions(track, [{width:w,height:h}]);
    }

    // refresh settings
    videoTrackSettings = track.getSettings ? track.getSettings() : videoTrackSettings;

    // mini bind
    if(miniVideo.srcObject !== stream) miniVideo.srcObject = stream;

    // apply persisted zoom by hybrid method
    await applyZoomHybrid(zoom, {animated:false, persist:false});

    // try continuous focus
    try {
      const caps = track.getCapabilities ? track.getCapabilities() : {};
      if(caps.focusMode && Array.isArray(caps.focusMode) && caps.focusMode.includes('continuous')){
        await track.applyConstraints({ advanced:[{ focusMode:'continuous' }] });
      }
    } catch(e){ /* ignore */ }

    updateCameraInfo();
    if(zoom>2) showMini(); else hideMini();
    setupMiniRAF();

  } catch(err){
    console.error('openCamera',err);
    alert('Erro ao abrir c√¢mera: '+(err && err.message ? err.message : err));
  }
}

/* ---------- hybrid zoom: hardware when available + digital scale ---------- */
async function applyZoomHybrid(target, opts={animated:true,persist:true}){
  target = clamp(Math.round(target), 1, 100); // integer zoom >=1
  const track = stream ? stream.getVideoTracks()[0] : null;
  const hasHW = !!(videoTrackCapabilities && 'zoom' in videoTrackCapabilities && track && track.applyConstraints);
  const hwMin = hasHW ? Number(videoTrackCapabilities.zoom.min || 1) : 1;
  const hwMax = hasHW ? Number(videoTrackCapabilities.zoom.max || 1) : 1;

  if(opts.animated){
    // animate from current zoom to target via RAF, integer steps
    const start = zoom;
    const steps = Math.max(6, Math.abs(target - start)); // more steps for larger jumps
    for(let i=1;i<=steps;i++){
      const t = start + (target-start)*(i/steps);
      const z = Math.round(t);
      if(hasHW){
        const hw = clamp(z, hwMin, hwMax);
        try{ await track.applyConstraints({ advanced:[{ zoom: hw }] }); } catch(e){}
        const digital = z / (hasHW ? hw : 1);
        applyDigital(digital);
      } else {
        applyDigital(z);
      }
      zoom = z;
      refreshZoomText();
      await delay(16);
    }
  } else {
    if(hasHW){
      const hw = clamp(target, hwMin, hwMax);
      try{ await track.applyConstraints({ advanced:[{ zoom: hw }] }); } catch(e){}
      applyDigital(target / hw);
    } else {
      applyDigital(target);
    }
    zoom = Math.round(target);
    refreshZoomText();
  }

  if(opts.persist) { localStorage.setItem('cam_zoom_v3', String(zoom)); }
}

function applyDigital(factor){
  factor = Math.max(1, factor || 1);
  preview.style.transform = `scale(${factor})`;
  // mini visibility handled elsewhere
}

function refreshZoomText(){
  zoomText.textContent = `${zoom}√ó`;
  zoomText.classList.add('show');
  setTimeout(()=>zoomText.classList.remove('show'),900);
  cameraInfo.textContent = `Wide ‚Ä¢ ${zoom}√ó`;
}

/* ---------- animate to targetZoom (smooth) ---------- */
let rafAnim = null;
function animateToTarget(){
  if(rafAnim) cancelAnimationFrame(rafAnim);
  const step = ()=>{
    if(zoom === targetZoom) return;
    const diff = targetZoom - zoom;
    // move 30% of difference then round to integer
    let next = zoom + Math.sign(diff) * Math.max(1, Math.round(Math.abs(diff)*0.3));
    next = clamp(Math.round(next), 1, 100);
    applyZoomHybrid(next, {animated:false,persist:false}).then(()=>{
      if(next !== targetZoom) rafAnim = requestAnimationFrame(step);
    });
  };
  rafAnim = requestAnimationFrame(step);
}

/* ---------- presets click ---------- */
presets.querySelectorAll('.preset').forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    const z = clamp(Math.round(Number(btn.dataset.zoom)),1,100);
    targetZoom = z;
    await applyZoomHybrid(z, {animated:true,persist:true});
    // toggle active
    presets.querySelectorAll('.preset').forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
  });
});

/* ---------- pinch support (integer zoom) ---------- */
let pinchStartDist = null, pinchStartZoom = null;
view.addEventListener('touchstart', e=>{
  if(e.touches.length === 2){
    pinchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    pinchStartZoom = zoom;
    // show zoom text briefly
    zoomText.classList.add('show');
  }
}, {passive:false});

view.addEventListener('touchmove', e=>{
  if(e.touches.length === 2 && pinchStartDist){
    e.preventDefault();
    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const ratio = d / pinchStartDist;
    let desired = Math.round(pinchStartZoom * ratio);
    desired = clamp(desired, 1, 100);
    // apply quickly but integer
    targetZoom = desired;
    animateToTarget();
  }
}, {passive:false});

view.addEventListener('touchend', async e=>{
  if(e.touches.length < 2){
    pinchStartDist = null;
    pinchStartZoom = null;
    // persist current zoom
    localStorage.setItem('cam_zoom_v3', String(zoom));
  }
}, {passive:true});

/* ---------- mini view rectangle logic (active only when zoom>2) ---------- */
let miniRAF = null;
function showMini(){ miniWrap.style.display = 'block'; startMiniRAF(); }
function hideMini(){ miniWrap.style.display = 'none'; stopMiniRAF(); }
function startMiniRAF(){
  if(miniRAF) return;
  const loop = ()=>{
    updateMiniRect();
    miniRAF = requestAnimationFrame(loop);
  };
  miniRAF = requestAnimationFrame(loop);
}
function stopMiniRAF(){ if(miniRAF) cancelAnimationFrame(miniRAF); miniRAF = null; }
function updateMiniRect(){
  if(zoom <= 2){ miniRect.style.display='none'; return; }
  if(!miniVideo.clientWidth || !miniVideo.clientHeight){ miniRect.style.display='none'; return; }
  miniRect.style.display='block';
  // visible fraction = 1 / digitalScale
  // we used preview.transform = scale(digitalFactor)
  // We approximate digitalFactor by zoom / hwZoomApplied (but we used integer zoom equalization)
  const digitalFactor = Math.max(1, zoom); // conservative
  const frac = 1 / digitalFactor;
  const w = miniVideo.clientWidth * frac;
  const h = miniVideo.clientHeight * frac;
  const left = (miniVideo.clientWidth - w)/2;
  const top = (miniVideo.clientHeight - h)/2;
  miniRect.style.width = `${w}px`;
  miniRect.style.height = `${h}px`;
  miniRect.style.left = `${left}px`;
  miniRect.style.top = `${top}px`;
}

/* ---------- shutter / capture ---------- */
async function captureImage(){
  shutter.disabled = true;
  flashQuick();
  try{
    const track = stream ? stream.getVideoTracks()[0] : null;
    let blob = null;

    // prefer ImageCapture.takePhoto if available
    if(window.ImageCapture && track){
      try{
        const ic = new ImageCapture(track);
        // try native size hints based on mode
        const opts = {};
        if(desiredMode === 'MP'){ const r = mpToResolution(cfg.MP.mp); opts.imageWidth = r.width; opts.imageHeight = r.height; }
        else { const [w,h] = cfg.P.p.split('x').map(Number); opts.imageWidth = w; opts.imageHeight = h; }
        blob = await ic.takePhoto(opts).catch(async ()=>{
          // try without opts
          return await ic.takePhoto().catch(()=>null);
        });
      }catch(e){
        console.warn('ImageCapture failed', e);
        blob = null;
      }
    }

    // fallback to canvas drawImage
    if(!blob){
      const ctx = canvas.getContext('2d');
      const vw = preview.videoWidth, vh = preview.videoHeight;
      canvas.width = vw; canvas.height = vh;
      ctx.clearRect(0,0,vw,vh);
      ctx.drawImage(preview, 0, 0, vw, vh);
      // if zoom >1 crop center
      if(zoom > 1){
        const cw = Math.round(vw / zoom), ch = Math.round(vh / zoom);
        const cx = Math.round((vw - cw)/2), cy = Math.round((vh - ch)/2);
        const im = ctx.getImageData(cx,cy,cw,ch);
        canvas.width = cw; canvas.height = ch; ctx.putImageData(im,0,0);
      }
      blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.92));
    }

    if(blob){
      const dataUrl = await blobToDataURL(blob);
      if(photos.length >= MAX_PHOTOS) photos.shift();
      photos.push({ dataUrl, ts: Date.now() });
      localStorage.setItem('cam_photos_v3', JSON.stringify(photos));
      refreshGalleryList();
    }

  }catch(err){
    console.error('capture error', err);
    alert('Erro ao capturar: '+(err && err.message?err.message:err));
  } finally {
    shutter.disabled = false;
  }
}

function blobToDataURL(blob){ return new Promise((res,rej)=>{ const fr = new FileReader(); fr.onload = ()=>res(fr.result); fr.onerror = rej; fr.readAsDataURL(blob); }); }

function flashQuick(){ flashOverlayEffect(); }
function flashOverlayEffect(){ const el = document.createElement('div'); el.style.position='fixed'; el.style.inset='0'; el.style.background='white'; el.style.opacity='0'; el.style.zIndex='9999'; document.body.appendChild(el); el.style.transition='opacity .12s'; requestAnimationFrame(()=>el.style.opacity='0.85'); setTimeout(()=>{ el.style.opacity='0'; setTimeout(()=>el.remove(),160); },140); }

/* ---------- gallery ---------- */
function refreshGalleryList(){
  galleryList.innerHTML = '';
  photos.slice().reverse().forEach((p,i)=>{
    const wrapper = document.createElement('div'); wrapper.className='gallery-item';
    const img = document.createElement('img'); img.src = p.dataUrl;
    const a = document.createElement('a'); a.href=p.dataUrl; a.download=`photo_${photos.length-i}.jpg`; a.textContent='Download';
    a.style.color='#0f0'; a.style.display='block'; a.style.marginTop='6px';
    wrapper.appendChild(img); wrapper.appendChild(a); galleryList.appendChild(wrapper);
  });
}

/* ---------- UI wiring ---------- */
agreeBtn.addEventListener('click', async ()=>{
  consent.style.display = 'none';
  app.style.display = 'block';
  app.setAttribute('aria-hidden','false');
  // pick main rear and open
  try{
    const devId = await pickRearMain();
    if(!devId){
      alert('Nenhuma c√¢mera traseira encontrada'); return;
    }
    await openCamera(devId);
  }catch(e){ console.error(e); alert('Erro ao iniciar c√¢mera: '+(e && e.message?e.message:e)); }
});

declineBtn.addEventListener('click', ()=>{ alert('Acesso negado.'); });

shutter.addEventListener('click', captureImage);

galleryBtn.addEventListener('click', ()=>{ galleryPanel.classList.toggle('open'); refreshGalleryList(); });
closeGallery.addEventListener('click', ()=>galleryPanel.classList.remove('open'));

settingsToggle.addEventListener('click', ()=>settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block');

applyRes.addEventListener('click', async ()=>{
  // read selections and re-open camera with new resolution
  cfg.MP.mp = mpSelect.value;
  cfg.P.p = pSelect.value;
  localStorage.setItem('cam_mp_v3', cfg.MP.mp);
  localStorage.setItem('cam_p_v3', cfg.P.p);
  showTemp('Aplicando resolu√ß√£o...', 800);
  if(chosenDeviceId) await openCamera(chosenDeviceId);
});

function showTemp(txt, ms=1200){
  cameraInfo.textContent = txt;
  cameraInfo.classList.add('show');
  setTimeout(()=>cameraInfo.classList.remove('show'), ms);
}

/* modes toggle and swipe */
modeBtns.forEach(btn=>{
  btn.addEventListener('click', async ()=>{
    modeBtns.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    desiredMode = btn.dataset.mode;
    localStorage.setItem('cam_mode_v3', desiredMode);
    // show panels accordingly
    mpPanel.style.display = desiredMode==='MP' ? 'block' : 'none';
    pPanel.style.display = desiredMode==='P' ? 'block' : 'none';
    if(chosenDeviceId) await openCamera(chosenDeviceId);
  });
});

// initialize UI based on stored state
(function initUI(){
  // set mode buttons
  modeBtns.forEach(b=>b.classList.toggle('active', b.dataset.mode === desiredMode));
  mpPanel.style.display = desiredMode==='MP' ? 'block' : 'none';
  pPanel.style.display = desiredMode==='P' ? 'block' : 'none';
  mpSelect.value = cfg.MP.mp;
  pSelect.value = cfg.P.p;
  refreshGalleryList();
  refreshZoomText();
})();

/* ---------- mini view RAF control on resize / visibility ---------- */
window.addEventListener('resize', ()=>{ if(zoom>2) updateMiniRect(); });

function setupMiniView(){
  if(stream && miniVideo.srcObject !== stream) miniVideo.srcObject = stream;
}

/* show/hide mini helper */
function showMini(){ miniWrap.style.display='block'; setupMiniView(); startMiniRAF(); }
function hideMini(){ miniWrap.style.display='none'; stopMiniRAF(); }

/* mini RAF */
let miniLoop = null;
function startMiniRAF(){
  if(miniLoop) return;
  const loop = ()=>{ updateMiniRect(); miniLoop = requestAnimationFrame(loop); };
  miniLoop = requestAnimationFrame(loop);
}
function stopMiniRAF(){ if(miniLoop) cancelAnimationFrame(miniLoop); miniLoop = null; }

/* ---------- update camera info display ---------- */
function updateCameraInfo(){
  cameraInfo.textContent = `Wide ‚Ä¢ ${zoom}√ó ‚Ä¢ ${videoTrackSettings?.width || '?'}√ó${videoTrackSettings?.height || '?'}`;
}

/* ---------- pinch and wheel fallback for desktop ---------- */
view.addEventListener('wheel', e=>{
  if(Math.abs(e.deltaY) < 1) return;
  const dir = e.deltaY < 0 ? 1 : -1;
  targetZoom = clamp(zoom + dir, 1, 100);
  animateToTarget();
});

/* ---------- final safety: ensure getUserMedia exists ---------- */
if(!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)){
  alert('Seu navegador n√£o suporta getUserMedia. Use um navegador moderno (Chrome/Edge/Firefox/Safari mobile atualizado).'
  );
}

/* Expose state for debugging */
window.__cam_state_v3 = ()=>({
  chosenDeviceId, devices, zoom, targetZoom, videoTrackSettings, videoTrackCapabilities, photos, desiredMode, cfg
});
</script>
</body>
</html>
